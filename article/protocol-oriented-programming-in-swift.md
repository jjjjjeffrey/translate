# 从 OOP 到 POP

我们来看一下软件设计中的常见问题。接着我们来探索一下传统的面向对象编程（OOP）有哪些限制，并且有什么新方法能让我们解决这些问题。我们重点来看一下 Swift 中有哪些设计模式可以提供这种方法。

## 面向对象编程：继承

数十年来，「继承」是我们最常用的一个技术，用来表达一个应用程序中我们与之交互的实体。如果使用得当，它会发挥极大作用。但是，在很多情况下，当应用程序中实体之间的关系需要表达一些复杂性，「继承」有一些严重的限制。

### 一个层级例子

让我们从一个虚构的例子开始，有这样一个系统，他的主要实体可以用下面这个类图来表示：

![picture-1](http://ww4.sinaimg.cn/large/65e4f1e6gw1f9v5vco2jaj20xk09uq3o.jpg)




假设现在有一个新的商业需求，需要我们更新并纳入到这个系统中。我们这个例子的层级非常简单。但是我们发现，当我们试图加入一些功能的时候，我们的解决方案非常容易使 整个系统架构变得更加脆弱和低效。

### 增加新功能

我们的新需求是以一个更深层次的分类来介绍我们的动物们，基于它们的移动方式：奔跑，游泳或者是飞翔。这些分类中的每一个都需要提供一些新功能。作为第一个实验，我们仅使用传统的「继承」方式来完成这个任务。

![picture-2](http://ww2.sinaimg.cn/large/006y8mN6gw1f9v5w2yfurj30xk0fiq42.jpg)

在「继承」模式下，增加新功能最简单的方法，就是将我们动物园的动物更进一步的分成 Runner，Swimmer 和 Flyer 这几个类。每一个类都必须实现特定的方法和属性。

不幸的是，在我们设想的这个情况下，已有的动物们的分类方式并不能很好的兼容这个新的类别。它们当中有一些动物并不是仅仅属于新分类中的一种，而是多种。以企鹅为代表的例子能很好的说明这个问题。尽管企鹅是鸟类的一种，我们通常可以预料到鸟是可以飞的，但企鹅并不能。企鹅可以跑，又可以游泳。所以企鹅不是一个 Flyer，它是一个 Runner 和 Swimmer。作为所有鸟类都能飞这个观念的反例，这意味着我们并不能在 Bird 这个类当中实现 fly() 这个方法。

一个可行的办法是我们可以复制这些代码到每一个子类中。这看起来足够简单，但是有很多潜在的地方需要我们来复制代码。为了避免复制代码，我们需要把新功能加在更上面的层级中，就是它们共同的父类中。从根本上说，我们为了权衡代码复用就会增加复杂度。

我们可以看到，我们从一个很简单的问题开始，完全依赖于「继承」，最后，设计了一个建立在这些紧密相连的类之上的分类系统。这个实现也许能很好的运行，但是，它缺乏灵活性，在未来我们想要对系统架构进行一些重大的改变时，将会变的异常困难。

## 传统的「继承」带来的问题

> 面向对象编程的问题是它携带了所有内部的实现。你想要一个香蕉，但你得到的是一只大猩猩拿着香蕉站在一大片热带雨林当中
>  Joe Armstrong

对于传统「继承」方式的主要问题，我个人的观点是：

- 描述关系的限制：如果我们仅仅依赖继承，那么唯一能够表达的关系是「is- a」（定义一个继承于父类的类）。这就限制了我们系统实体的设计。举个例子，使用「has-a」这种关系可以允许你表达一个对象包含简单的对象。通过这种额外的灵活度，使得我们可以把功能分解到各个协作对象。
- 不是足够灵活：当我们使用继承层级，在设计的初始阶段，我们必须要想出一个描述我们系统的对象的分类。不幸的是，我们并不能预测需求将会怎样变化，并且总有一天我们会发现当初我们的设计并不能很好的适应一个特定的使用案例。这是关系描述限制的问题所导致的最直接的结果。
- 基于类是脆弱的：在继承层级关系中，父类是脆弱的。这是因为继承层级是由紧密相连的类组成的，任何对父类的改变都会让其所有相关子类受到连锁反应的影响。我们将很容易发现，即使对父类进行一个非常微小的修改，都会对我们的整个层级系统造成潜在的灾难性的后果或者是消极的影响。除此之外，即使我们足够小心来确保这些改变不会带来计划之外的影响，但这真的很容易就让我们的父类拥有太多的职责。这打破了「单一职责原则」，并且把脆弱带入我们的架构。
- 多重继承：一些编程语言试图让「继承」变的更加灵活，它们引入了多重继承的概念。主要思路就是允许子类可以拥有一个以上的父类。不幸的是，伴随这种模式而来的复杂性和歧义，极大的限制了它的使用。事实上，很多现代编程语言并没有选择支持多重继承（ Swift 是其中之一）。

## 一个更好的方法：组合而不是继承

> 面向接口编程，而不是面向实现。
> 更多的使用对象组合而不是类继承。
> Design Patterns — GoF

采用组合替代继承可以实现更高效的代码复用。通过对象的组合我们可以把简单的对象合并成复杂的对象。

### Interface，Traits，Mixins

组合手段的最初想法是 Interface 的概念，它声明了一个的方法列表，那些想支持新功能的类来实现它。随着时间的推移，不同的语言对这个概念进行了引申，即 Trait 和 Mixin。不同语言对 Interfaces、Traits 和 Mixins 的定义方式不同，也有一些重叠。但是通常来讲，这个抽象概念可以简短总结如下：

- Interface：包含方法声明
- Trait：一个 Interface 包含方法主体
- Mixin：一个 Trait 外加属性和状态

### 一个改进的应用架构

我们来看一下当应用架构引入了对象组合以后，它是怎样克服传统的继承所固有的限制。起初，我们试着引入几个类，分别是 Runner，Swimmer 和 Flyer。现在，我们抛弃继承，取而代之的是，我们创建相关的接口用来声明我们需要的功能。这样决定的结果是，之前的 Runner，Swimmer 和 Flyer 类分别会变成 Runnable，Swimmable 和 Flyable 接口。已有的类可以通过组合这些声明了功能的接口来获得新的能力。

现在，通过将一个具体的类和一个或者多个接口组合起来，来实现我们动物园的动物。改进后的架构图如下：

> 新架构图

![picture-3](http://ww3.sinaimg.cn/large/006y8mN6gw1f9v5wm7pxej30xk0g2wg6.jpg)

## Swift 的解决方案：协议和协议扩展

Swift 采用其特有的术语来定义前面这个架构图所表达的构思：

- Protocols：提供一个创建接口的方式
- Protocol Extensions：提供默认实现
- Conforming to a protocol：实现一个特定的接口

即使可以给一个 Protocol 添加属性，当一个类遵从一个 Protocol 时，Swift 的编译器仍然需要我们初始化这些声明在 Protocol 中的属性。非常值得注意的是，属性值存储在类的实例中，不是在 Protocol 自己里面。这就是为什么我们说 Swift 并不完整的支持 Mixins。

回到我们的应用中，让我们瞧一瞧怎样用 Swift 来实现我们的组合架构。举个例子，Runnable 实体可以写成这样：
```swift
protocol Runnable {
    var groundSpeed: Double { get }
    func run() -> String
}
extension Runnable {
    func run() -> String {
        return "Running at \(groundSpeed) mph"
    } 
}
```
Runnable 协议定义了接口，然后 Runnable 协议扩展提供了协议方法中的默认实现。Class 遵从了 Runnable 协议，要实现它的接口，既可以直接使用协议扩展提供的默认实现，也可以自定义实现。

同样的方法可以实现 Swimmable 和 Flyable 的功能：

```swift
protocol Swimmable {
    var waterSpeed: Double { get }
    func swim() -> String
}
extension Swimmable {
    func swim() -> String {
        return "Swimming at \(waterSpeed) mph"
    } 
}

protocol Flyable {
    var airSpeed: Double { get }
    func fly() -> String
}
extension Flyable {
    func fly() -> String {
        return "Flying at \(airSpeed) mph"
    } 
}
```

现在，为了表达企鹅既能奔跑又能游泳，我们就可以非常容易的让 Penguin 类来遵从 Runnable 和 Swimmable 协议：

```swift
class Penguin : Bird, Runnable, Swimmable {
    var groundSpeed = 2.0
    var waterSpeed = 25.0
}
```

## 总结
你可以从这里下载源代码。

这篇文章中我们检查了传统继承模式的常见问题，并且想办法解决这些问题。为了远离这种紧密相连的层级结构，我们通过采用对象组合的方式设计出一个更加灵活的架构来达成了我们的目标。

尤其是，我们探索了如何利用 Swift 的协议和协议扩展来实现这种改进过的架构。我们学习了创建 Protocol 并使用 Protocol Extensions 来扩展它来提供默认的方法实现。以完全依赖传统的继承的模式来实现作为对比，这种实现方式让我们的代码就可以非常干净，优雅。


[点击阅读原文](https://medium.com/@andrea.prearo/protocol-oriented-programming-in-swift-daba92bc9c98#.l88bt3hhr)

